function tf=load_fits_file_fun(varargin)

% The function load_fits_file_fun(filename) is designed
% to load the scienta data file that generated by ALS labview based Scienta
% data taking software.
% Input "filename" is a string that contain the full filename
% with its path
%
% The function then loads the file into the workspace with the
% variable name the same as the filename.
% The variable contains the field "info", axis information of
% "x", "y" and "z" depending on the measuring data's dimension
% and the field "value" for the bulk data.
%
% In case bugs are found, please contact the author (Yulin Chen) by
% Email: yulin.chen@gmail.com

% return true if successfully loaded, otherwise return false.

if nargin~=1
%     errordlg('There should be only one input -- the data filename','Wrong argument No.');
    tf=false;
    return
end

[~, filename, ext] = fileparts(varargin{1});
if ~isempty(str2double( filename(1) ))
    filename=['A' filename];
end

if ~strcmpi(ext,'.fits')
%     errordlg(['The file "' varargin{1} '" is not a .txt file!'],'Wrong file format');
    tf=false;
    return
end

fid=fopen(varargin{1}); % open data file
info_line=fgetl(fid);
if isempty(strfind(info_line,'COMMENT Created by eli''s labview vi'))
    tf=false;
    fclose(fid);
    return
end
fclose(fid);

data_tmp.fitsinfo=fitsinfo(varargin{1});

keywords_primary=data_tmp.fitsinfo.PrimaryData.Keywords;
keywords_binarytable=data_tmp.fitsinfo.BinaryTable.Keywords;
centerpixcel=482.497;

n_loops2=1;
for i=1:size(keywords_primary,1)
    keyword=keywords_primary{i,1};
    if strcmpi(keyword,'MONOEV')
        data_tmp.info.PhotonEnergy=keywords_primary{i,2};
    elseif strcmpi(keyword,'UNDGAP')
        data_tmp.info.UndulatorGap=keywords_primary{i,2};
    elseif strcmpi(keyword,'EXITWIDT')
        data_tmp.info.ExitSlitWidth=keywords_primary{i,2};
    elseif strcmpi(keyword,'ENTRWIDT')
        data_tmp.info.EntranceSlitWidth=keywords_primary{i,2};
    elseif strcmpi(keyword,'NMSBDV0')
        n_subdevices=keywords_primary{i,2};
    elseif strcmpi(keyword,'N_0_0')
        n_loops1=keywords_primary{i,2};
    elseif strcmpi(keyword,'N_0_1')
        n_loops2=keywords_primary{i,2};
    elseif strcmpi(keyword,'SS_NUM')
        n_regions=keywords_primary{i,2};
    elseif strcmpi(keyword,'SS_HV')
        E_offset=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSLNM',5)
        index=str2double(keyword(6:end))+1;
        lensmode{index}=keywords_primary{i,2};
        switch lensmode{index}
            case 'Angular30'
                anglePpixcel{index}=0.04631;   %0.04631;
            case 'Angular14'
                anglePpixcel{index}=0.04631*14/30;   % to be determined
            otherwise
                anglePpixcel{index}=0.04631*sscanf(lensmode{index},'Angular%d')/30;    % to be determined
        end
    elseif strncmpi(keyword,'SSPE_',5)
        index=str2double(keyword(6:end))+1;
        PE{index}=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSFR_',5)
        index=str2double(keyword(6:end))+1;
        steptime{index}=keywords_primary{i,2}*2/30;
    elseif strncmpi(keyword,'SSSW',4)
        index=str2double(keyword(5:end))+1;
        n_sweeps{index}=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSX0_',5)
        index=str2double(keyword(6:end))+1;
        xchannel1{index}=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSX1_',5)
        index=str2double(keyword(6:end))+1;
        xchannel2{index}=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSY0_',5)
        index=str2double(keyword(6:end))+1;
        ychannel1{index}=keywords_primary{i,2};
    elseif strncmpi(keyword,'SSY1_',5)
        index=str2double(keyword(6:end))+1;
        ychannel2{index}=keywords_primary{i,2};    
    end
end

for i=1:size(keywords_binarytable,1)
    keyword=keywords_binarytable{i,1};
    if strncmpi(keyword,'TTYPE',5)
        index=str2double(keyword(6:end));
        ttype{index}=keywords_binarytable{i,2};
    elseif strncmpi(keyword,'TDIM',4)
        index=str2double(keyword(5:end));
        tmp=sscanf(keywords_binarytable{i,2},'(%d,%d)');
        nx{index}=tmp(1);
        ny{index}=tmp(2);
    elseif strncmpi(keyword,'TRVAL',5)
        index=str2double(keyword(6:end));
        tmp=sscanf(keywords_binarytable{i,2},'(%f,%f)');
        x0{index}=tmp(1);
        y0{index}=tmp(2);
    elseif strncmpi(keyword,'TDELT',5)
        index=str2double(keyword(6:end));
        tmp=sscanf(keywords_binarytable{i,2},'(%f,%f)');
        dx{index}=tmp(1);
        dy{index}=tmp(2);
    end
end

vdata=fitsread(varargin{1},'binarytable','info',data_tmp.fitsinfo);

if n_loops1==1 && n_loops2==1
    for i=1:n_regions
        data=data_tmp;
        data.info.LensMode=lensmode{i};
        data.info.PassEnergy=PE{i};
        data.info.StepTime=steptime{i};
        data.info.Nsweeps=n_sweeps{i};
        data.info.FirstXChannel=xchannel1{i};
        data.info.LastXChannel=xchannel2{i};
        data.info.FirstYChannel=ychannel1{i};
        data.info.LastYChannel=ychannel2{i};
        data.info.PhotonEnergy=E_offset;
        
        v_x0 = (x0{i+2}-centerpixcel)*anglePpixcel{i};    % Do not *dx here --2012/12/19 BZ--
        v_dx = anglePpixcel{i}*dx{i+2};
        data.x=v_x0:v_dx:v_x0+v_dx*(nx{i+2}-1);
        data.y=E_offset+(y0{i+2}:dy{i+2}:y0{i+2}+dy{i+2}*(ny{i+2}-1));
        data.value=reshape(vdata{i+2},[nx{i+2} ny{i+2}]);
        if n_regions==1
            assignin('base',filename,data)
        else
            assignin('base',[filename '_' num2str(i)],data)
        end
    end
elseif n_regions==1 && n_loops1>1
    for i=1:n_loops2
        data=data_tmp;
        data.info.LensMode=lensmode{1};
        data.info.PassEnergy=PE{1};
        data.info.StepTime=steptime{1};
        data.info.Nsweeps=n_sweeps{1};
        data.info.FirstXChannel=xchannel1{1};
        data.info.LastXChannel=xchannel2{1};
        data.info.FirstYChannel=ychannel1{1};
        data.info.LastYChannel=ychannel2{1};
        
        v_x0 = (x0{n_subdevices+2}-centerpixcel)*anglePpixcel{1};    % Do not *dx here --2012/12/19 BZ--
        v_dx = anglePpixcel{1}*dx{n_subdevices+2};
        
        if n_subdevices==1 && strcmpi(ttype{2},'mono_eV')   % hv-dep
            if length(vdata{2})<n_loops1     % in case the measurement was forced stopped
                n_loops1=length(vdata{2});
            end
            for j=1:n_loops1
                data.x=v_x0:v_dx:v_x0+v_dx*(nx{n_subdevices+2}-1);
                data.y=y0{n_subdevices+2}:dy{n_subdevices+2}:y0{n_subdevices+2}+dy{n_subdevices+2}*(ny{n_subdevices+2}-1);
                data.y=data.y+vdata{2}(j);
                data.info.PhotonEnergy=vdata{2}(j);
                data.value=reshape(vdata{3}(j,:),[nx{3} ny{3}]);
                assignin('base',[filename '_' eval(['num2str(j,''%.' num2str(floor(log10(n_loops1))+1) 'd'')'])],data)
%                 assignin('base',[filename '_' num2str(j)],data)
            end
        else    % mapping
            data.time=vdata{1}';
            data.x=vdata{2}';
            if length(data.x)<n_loops1     % in case the measurement was forced stopped
                n_loops1=length(data.x);
            end
            data.y=v_x0:v_dx:v_x0+v_dx*(nx{n_subdevices+2}-1);
            data.z=y0{n_subdevices+2}:dy{n_subdevices+2}:y0{n_subdevices+2}+dy{n_subdevices+2}*(ny{n_subdevices+2}-1);
            if n_subdevices==2 && strcmpi(ttype{3},'mono_eV')
                data.z=data.z+vdata{3}(1+n_loops1*(i-1));
                data.info.PhotonEnergy=vdata{3}(1+n_loops1*(i-1));
            else
                data.z=data.z+E_offset;
                data.info.PhotonEnergy=E_offset;
            end
            data.value=reshape(vdata{n_subdevices+2}(1+n_loops1*(i-1):n_loops1*i,:),[n_loops1 nx{n_subdevices+2} ny{n_subdevices+2}]);
            if n_loops2==1
                assignin('base',filename,data)
            else
                assignin('base',[filename '_' num2str(i)],data)
            end
        end
    end
elseif n_regions>1 && n_loops1>1 && n_loops2==1
    for i=1:n_regions
        data=data_tmp;
        data.info.LensMode=lensmode{1};
        data.info.PassEnergy=PE{1};
        data.info.StepTime=steptime{1};
        data.info.Nsweeps=n_sweeps{1};
        data.info.FirstXChannel=xchannel1{1};
        data.info.LastXChannel=xchannel2{1};
        data.info.FirstYChannel=ychannel1{1};
        data.info.LastYChannel=ychannel2{1};
        
        v_x0 = (x0{i+2}-centerpixcel)*anglePpixcel{1};    % Do not *dx here --2012/12/19 BZ--
        v_dx = anglePpixcel{1}*dx{i+2};
        
        if strcmpi(ttype{2},'mono_eV')   % hv-dep
            if length(vdata{2})<n_loops1     % in case the measurement was forced stopped
                n_loops1=length(vdata{2});
            end
            for j=1:n_loops1
                data.x=v_x0:v_dx:v_x0+v_dx*(nx{i+2}-1);
                data.y=y0{i+2}:dy{i+2}:y0{i+2}+dy{i+2}*(ny{i+2}-1);
                data.y=data.y+vdata{2}(j);
                data.info.PhotonEnergy=vdata{2}(j);
                data.value=reshape(vdata{i+2}(j,:),[nx{i+2} ny{i+2}]);
                assignin('base',[filename '_' num2str(i) '_' eval(['num2str(j,''%.' num2str(floor(log10(n_loops1))+1) 'd'')'])],data)
            end
        else    % mapping            
            data.time=vdata{1}';
            data.x=vdata{2}';
            if length(data.x)<n_loops1     % in case the measurement was forced stopped
                n_loops1=length(data.x);
            end
            data.y=v_x0:v_dx:v_x0+v_dx*(nx{i+2}-1);
            data.z=y0{i+2}:dy{i+2}:y0{i+2}+dy{i+2}*(ny{i+2}-1);
            
            data.z=data.z+E_offset;
            data.info.PhotonEnergy=E_offset;
            
            data.value=reshape(vdata{i+2}(:,:),[length(data.x) nx{i+2} ny{i+2}]);
            
            assignin('base',[filename '_' num2str(i)],data)
            
        end
    end
end


tf=true;

